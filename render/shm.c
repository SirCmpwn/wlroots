#include <stdlib.h>

#include <drm_fourcc.h>
#include <pixman.h>
#include <wayland-server.h>

#include <wlr/render/shm.h>
#include <wlr/render/format_set.h>
#include <wlr/util/log.h>

/*
 * wl_shm_format is a subset of DRM fourcc formats (excluding ARGB888 and
 * XRGB8888), so we need to remove some formats which aren't compatible.
 *
 * This list can be generated by
 * ```
 * grep -ohE '(DRM|WL_SHM)_FORMAT_[AXRGBYUVNC]{1,4}[0-9]+(_A8)?' \
 * 	/usr/include/wayland-server-protocol \
 *	/usr/include/libdrm/drm_fourcc.h \
 *	| sed -E 's/^.*FORMAT_//' | sort | uniq -u
 *
 * ```
 */

static bool is_shm_format_compatible(uint32_t format) {
	switch (format) {
	case DRM_FORMAT_BGR565_A8:
	case DRM_FORMAT_BGR888_A8:
	case DRM_FORMAT_BGRX8888_A8:
	case DRM_FORMAT_GR1616:
	case DRM_FORMAT_GR88:
	case DRM_FORMAT_NV24:
	case DRM_FORMAT_NV42:
	case DRM_FORMAT_R16:
	case DRM_FORMAT_R8:
	case DRM_FORMAT_RG1616:
	case DRM_FORMAT_RG88:
	case DRM_FORMAT_RGB565_A8:
	case DRM_FORMAT_RGB888_A8:
	case DRM_FORMAT_RGBX8888_A8:
	case DRM_FORMAT_XBGR8888_A8:
	case DRM_FORMAT_XRGB8888_A8:
	// These two are special and advertised by libwayland automatically
	case DRM_FORMAT_ARGB8888:
	case DRM_FORMAT_XRGB8888:
		return false;
	default:
		return true;
	}
}

bool wlr_shm_init(struct wl_display *display, const struct wlr_format_set *fmts) {
	for (size_t i = 0; i < fmts->len; ++i) {
		const struct wlr_format *fmt = fmts->formats[i];

		if (is_shm_format_compatible(fmt->format)) {
			wl_display_add_shm_format(display, fmt->format);
		}

	}

	if (wl_display_init_shm(display) != 0) {
		wlr_log_errno(WLR_ERROR, "Failed to initialise wayland shm");
		return false;
	}

	return true;
}

void wlr_shm_apply_damage(struct wl_shm_buffer *buffer, pixman_region32_t *damage,
		void *userdata, wlr_shm_write_fn write_fn) {
	uint32_t stride = wl_shm_buffer_get_stride(buffer);
	uint32_t width = wl_shm_buffer_get_width(buffer);
	uint32_t height = wl_shm_buffer_get_height(buffer);

	pixman_region32_t clipped;
	pixman_region32_init_rect(&clipped, 0, 0, width, height);
	if (damage) {
		pixman_region32_intersect(&clipped, &clipped, damage);
	}

	int n;
	pixman_box32_t *boxes = pixman_region32_rectangles(&clipped, &n);

	wl_shm_buffer_begin_access(buffer);
	void *data = wl_shm_buffer_get_data(buffer);

	for (int i = 0; i < n; ++i) {
		pixman_box32_t *b = &boxes[i];
		pixman_rectangle32_t rect = {
			.x = b->x1,
			.y = b->y1,
			.width = b->x2 - b->x1,
			.height = b->y2 - b->y1,
		};
		write_fn(userdata, data, stride, &rect);
	}

	wl_shm_buffer_end_access(buffer);
	pixman_region32_fini(&clipped);
}
